{"version":3,"sources":["assets/puppy.jpg","constants/sketch.js","constants/Sorting.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","swap","array","i","j","t","sketch","p","img","arrayB","arrayC","blockWidth","blockHeight","arrayA","path","puppy","swapPixels","pixelArray","preload","loadImage","setup","resize","width","height","p5canvas","createCanvas","canvas","partition","background","n","length","Math","random","shuffle","draw","iterator","measure","min","selectionSort","compare","a","b","bubbleSort","image","mousePressed","saveFrames","data","print","grabValue","object","index","newBlock","get","push","App","props","myRef","React","createRef","this","p5","current","className","ref","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.53ea23bb.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/puppy.7170c82a.jpg\";","import puppy from \"../assets/puppy.jpg\"\nimport { selectionSort, bubbleSort, mergeSort, quickSort , shuffle } from \"./Sorting\"\n\nconst sketch = (p) => {\n    let img, arrayA = [], arrayB, arrayC, arrayD, m = 1, amountX = 30, amountY = 30;\n    let i = 0;\n    let blockWidth, blockHeight;\n    const path = puppy\n    let canvas\n    let encoder = \n\n    p.swapPixels = (pixelArray,i,j) => {\n        swap(pixelArray[i], pixelArray[j])\n        swap(pixelArray[i + 1], pixelArray[j + 1])\n        swap(pixelArray[i + 1], pixelArray[j + 1])\n    } \n\n    p.preload = () => {\n        img = p.loadImage(path)\n    }\n\n    p.setup = () => {\n        img.resize(img.width / 2, img.height/2)\n        img.resize(img.width - img.width % amountX, img.height - img.height % amountY)\n        blockWidth = img.width / amountX\n        blockHeight = img.height / amountY\n        let p5canvas = p.createCanvas(img.width,img.height * 2);\n        canvas = p5canvas.canvas\n        arrayA = p.partition(img);\n        p.background(255);\n        // p.image(img, img.width, 0);\n        shuffle(arrayA)\n        arrayB = [...arrayA]\n        arrayC = [...arrayA]\n        arrayD = [...arrayA]\n    } \n\n    p.draw = () => {\n        // if (m < arrayA.length) {\n        //     mergeSort(arrayA, m)\n        //     m <<= 1;\n        // } \n        selectionSort(arrayB, i, p.compare)\n        bubbleSort(arrayC, i, p.compare)\n        // quickSort(arrayD)\n\n        i++\n        for (let i = 0; i < amountX; i++) {\n            for (let j = 0; j < amountY; j++) {\n                // p.image(arrayA[i + j * amountX].img, i * blockWidth, j * blockHeight)\n                p.image(arrayB[i + j * amountX].img, i * blockWidth, j * blockHeight + img.height)\n                p.image(arrayC[i + j * amountX].img, i * blockWidth, j * blockHeight)\n                // p.image(arrayD[i + j * amountX].img, i * blockWidth + img.width, j * blockHeight + img.height)\n\n            }\n        }\n    }\n\n    p.mousePressed = () => {\n        p.saveFrames('out', 'png', 1, 25, data => {\n          p.print(data);\n        });\n    }\n\n    p.grabValue = (object) => {\n        return object.index\n    }\n\n    p.compare = (a,b) => {\n        return a.index <= b.index\n    }\n\n    p.partition = (img) => {\n        let array = []\n        let newBlock\n        for (let j = 0; j < amountY; j++) {\n            for (let i = 0; i < amountX; i++) {\n                newBlock = img.get(i * blockWidth, j * blockHeight, blockWidth, blockHeight)\n                array.push({img: newBlock, index: i + j * amountX})\n            }\n        }\n        return array\n    }\n}\n\nconst swap = (array, i, j) => {\n    let t = array[i];\n    array[i] = array[j];\n    array[j] = array[t];\n}\n\nexport default sketch","\nexport const bubbleSort = (array, iterator, measure = (a,b) => a < b) => {\n    for (let j = 0; j < array.length - iterator - 1; j++) {\n        if (measure(array[j + 1], array[j])) {\n            let t = array[j];\n            array[j] = array[j + 1];\n            array[j + 1] = t;\n        }\n    }\n}\n\nexport const shuffle = (array) => {\n    let n = array.length, t, i;\n    while (n) {\n        i = Math.random() * n-- | 0; // 0 â‰¤ i < n\n        t = array[n];\n        array[n] = array[i];\n        array[i] = t;\n    }\n  return array;\n}\n\nexport const mergeSort = async (array, m)  => {\n    var n = array.length, a1 = new Array(n);\n      for (var i = 0; i < n; i += m << 1) {\n        var left = i,\n            right = Math.min(i + m, n),\n            end = Math.min(i + (m << 1), n);\n            merge(array, a1, left, right, end);\n      }\n    for (let i = 0; i < n; i++) {\n        array[i] = a1[i]\n    }\n  }\n  \nconst merge = (a0, a1, left, right, end) => {\n    for (var i0 = left, i1 = right; left < end; ++left) {\n      if (i0 < right && (i1 >= end || a0[i0].index <= a0[i1].index)) {\n        a1[left] = a0[i0++];\n      } else {\n        a1[left] = a0[i1++];\n      }\n    }\n  }\n\nexport const quickSort = async (array, start = 0, end = array.length - 1) => {\n    await sleep(10)\n    if (start >= end) {\n        return\n    }\n    let index = partition(array, start, end)\n    await Promise.all([\n        quickSort(array, start, index - 1),\n        quickSort(array, index + 1, end)\n    ])\n}\n\nconst partition = (array, start, end) => {\n    let pivotIndex = start;\n    let pivotValue = array[end].index;\n    for (let i = start; i < end; i++) {\n        if (array[i].index < pivotValue) {\n            swap(array, i, pivotIndex)\n            pivotIndex++;\n        }\n    }\n    swap(array, pivotIndex, end)\n    return pivotIndex;\n}\n\nconst swap = async (array, i, j) => {\n    let temp = array[i]\n    array[i] = array[j]\n    array[j] = temp\n}\n\nconst sleep = (time) => new Promise(resolve => setTimeout(resolve, time))\n\nexport const selectionSort = (array, iterator, measure) => {\n    let min = iterator;\n    for (let i = iterator + 1; i < array.length; i++) {\n        if (measure(array[i], array[min])) min = i\n    }\n    let t = array[min];\n    array[min] = array[iterator];\n    array[iterator] = t;\n}","import React from 'react';\nimport p5 from 'p5';\nimport sketch from './constants/sketch';\nimport './App.css';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myRef = React.createRef();\n  }\n\n  componentDidMount() {\n    this.sketch = new p5(sketch, this.myRef.current)\n  }\n\n  render() {\n    return (\n      <div className=\"App\" ref={this.myRef}>\n        \n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}