{"version":3,"sources":["constants/sketch.js","App.js","serviceWorker.js","index.js"],"names":["swap","array","i","j","t","shuffle","n","length","Math","random","sketch","p","img","blockWidth","blockHeight","swapPixels","pixelArray","preload","loadImage","setup","resize","width","height","createCanvas","partition","background","image","draw","index","noLoop","newBlock","get","push","App","props","myRef","React","createRef","this","p5","current","className","ref","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"6SA4DMA,G,KAAO,SAACC,EAAOC,EAAGC,GACpB,IAAIC,EAAIH,EAAMC,GACdD,EAAMC,GAAKD,EAAME,GACjBF,EAAME,GAAKF,EAAMG,KAiCfC,EAAU,SAACJ,GAEb,IADA,IAAsBG,EAAGF,EAArBI,EAAIL,EAAMM,OACPD,GACHJ,EAAIM,KAAKC,SAAWH,IAAM,EAC1BF,EAAIH,EAAMK,GACVL,EAAMK,GAAKL,EAAMC,GACjBD,EAAMC,GAAKE,EAEjB,OAAOH,GAGMS,EA3GA,SAACC,GACZ,IAAIC,EAEAC,EAAYC,EAFFb,EAAQ,GAClBC,EAAI,EAIRS,EAAEI,WAAa,SAACC,EAAWd,EAAEC,GACzBH,EAAKgB,EAAWd,GAAIc,EAAWb,IAC/BH,EAAKgB,EAAWd,EAAI,GAAIc,EAAWb,EAAI,IACvCH,EAAKgB,EAAWd,EAAI,GAAIc,EAAWb,EAAI,KAG3CQ,EAAEM,QAAU,WACRL,EAAMD,EAAEO,UATC,gBAYbP,EAAEQ,MAAQ,WACNP,EAAIQ,OAAOR,EAAIS,MAAQT,EAAIS,MAhBgB,GAgBCT,EAAIU,OAASV,EAAIU,OAhBJ,IAiBzDT,EAAaD,EAAIS,MAjB0B,GAkB3CP,EAAcF,EAAIU,OAlBuC,GAmBzDX,EAAEY,aAAyB,EAAZX,EAAIS,MAAUT,EAAIU,QACjCrB,EAAQU,EAAEa,UAAUZ,GACpBD,EAAEc,WAAW,KACbd,EAAEe,MAAMd,EAAKA,EAAIS,MAAO,GACxBhB,EAAQJ,IAGZU,EAAEgB,KAAO,WACL,GAAIzB,EAAID,EAAMM,OAAQ,CAClB,IAAK,IAAIJ,EAAI,EAAGA,EAAIF,EAAMM,OAASL,EAAI,EAAGC,IACtC,GAAIF,EAAME,EAAI,GAAGyB,MAAQ3B,EAAME,GAAGyB,MAAO,CACrC,IAAIxB,EAAIH,EAAME,GACdF,EAAME,GAAKF,EAAME,EAAI,GACrBF,EAAME,EAAI,GAAKC,EAGvBF,SAEAS,EAAEkB,SAEN,IAAK,IAAI3B,EAAI,EAAGA,EAvC2B,GAuCdA,IACzB,IAAK,IAAIC,EAAI,EAAGA,EAxCqC,GAwCxBA,IACzBQ,EAAEe,MAAMzB,EAAMC,EAzCqB,GAyCjBC,GAAaS,IAAKV,EAAIW,EAAYV,EAAIW,IAKpEH,EAAEa,UAAY,SAACZ,GAGX,IAFA,IACIkB,EADA7B,EAAQ,GAEHE,EAAI,EAAGA,EAjDyC,GAiD5BA,IACzB,IAAK,IAAID,EAAI,EAAGA,EAlDuB,GAkDVA,IACzB4B,EAAWlB,EAAImB,IAAI7B,EAAIW,EAAYV,EAAIW,EAAaD,EAAYC,GAChEb,EAAM+B,KAAK,CAACpB,IAAKkB,EAAUF,MAAO1B,EApDC,GAoDGC,IAG9C,OAAOF,IChCAgC,G,kBAlBb,WAAYC,GAAQ,IAAD,8BACjB,4CAAMA,KACDC,MAAQC,IAAMC,YAFF,E,iFAMjBC,KAAK5B,OAAS,IAAI6B,IAAG7B,EAAQ4B,KAAKH,MAAMK,W,+BAIxC,OACE,yBAAKC,UAAU,MAAMC,IAAKJ,KAAKH,Y,GAZnBC,IAAMO,YCOJC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.52991bca.chunk.js","sourcesContent":["const sketch = (p) => {\n    let img, loc, array = [], index = 1, amountX = 30, amountY = 30;\n    let i = 0;\n    let blockWidth, blockHeight;\n    const path = './puppy.jpg'\n\n    p.swapPixels = (pixelArray,i,j) => {\n        swap(pixelArray[i], pixelArray[j])\n        swap(pixelArray[i + 1], pixelArray[j + 1])\n        swap(pixelArray[i + 1], pixelArray[j + 1])\n    } \n\n    p.preload = () => {\n        img = p.loadImage(path)\n    }\n\n    p.setup = () => {\n        img.resize(img.width - img.width % amountX, img.height - img.height % amountY)\n        blockWidth = img.width / amountX\n        blockHeight = img.height / amountY\n        p.createCanvas(img.width * 2,img.height);\n        array = p.partition(img);\n        p.background(255);\n        p.image(img, img.width, 0);\n        shuffle(array)\n    } \n\n    p.draw = () => {\n        if (i < array.length) {\n            for (let j = 0; j < array.length - i - 1; j++) {\n                if (array[j + 1].index < array[j].index) {\n                    let t = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = t;\n                }\n            }\n            i++;\n        } else {\n            p.noLoop()\n        }\n        for (let i = 0; i < amountX; i++) {\n            for (let j = 0; j < amountY; j++) {\n                p.image(array[i + j * amountX].img, i * blockWidth, j * blockHeight)\n            }\n        }\n    }\n\n    p.partition = (img) => {\n        let array = []\n        let newBlock\n        for (let j = 0; j < amountY; j++) {\n            for (let i = 0; i < amountX; i++) {\n                newBlock = img.get(i * blockWidth, j * blockHeight, blockWidth, blockHeight)\n                array.push({img: newBlock, index: i + j * amountX})\n            }\n        }\n        return array\n    }\n}\n\nconst swap = (array, i, j) => {\n    let t = array[i];\n    array[i] = array[j];\n    array[j] = array[t];\n}\n\nconst iterateMergeSort = (index, array, measure) => {\n    let result = [], left, right;\n    for (let i = 0; i < array.length; i += index * 2) {\n        left = array.slice(i,i + index)\n        right = array.slice(i + index, i + 2 * index)\n        result.push(...merge(left, right, measure))\n    }\n    return result\n}\n\nconst merge = (a, b, measure) => {\n    let i = 0, j = 0, result = [];\n    while(i < a.length && j < b.length) {\n        if (measure(a[i],b[j])) {\n            result.push(a[i]);\n            i++;\n        } else {\n            result.push(b[j])\n            j++;\n        }\n    }\n    if (i === a.length) {\n        result.push(...b.slice(j))\n    } \n    if (j === b.length) {\n        result.push(...a.slice(i))\n    }\n    return result\n}\n\nconst shuffle = (array) => {\n    let n = array.length, t, i;\n    while (n) {\n        i = Math.random() * n-- | 0; // 0 â‰¤ i < n\n        t = array[n];\n        array[n] = array[i];\n        array[i] = t;\n    }\n  return array;\n}\n\nexport default sketch","import React from 'react';\nimport p5 from 'p5';\nimport sketch from './constants/sketch';\nimport './App.css';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myRef = React.createRef();\n  }\n\n  componentDidMount() {\n    this.sketch = new p5(sketch, this.myRef.current)\n  }\n\n  render() {\n    return (\n      <div className=\"App\" ref={this.myRef}>\n        \n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}